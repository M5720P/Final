import java.io.*;
import java.util.*;

public class Kdnn {

  
    static class Word {
        String word;       
        float[] vector;    // The vector that represents the word

        Word(String word, float[] vector) {
            this.word = word;      
            this.vector = vector;  
        }
    }
 static class KDTree {
        
        // Node class represents each point (word and its vector) in the tree
        static class Node {
            Word word;         
            Node left;          
            Node right;         
            int dimension;      

            Node(Word word, int dimension) {
                this.word = word;                   // Set the word at the node
                this.dimension = dimension;         // Set the dimension for splitting
            }
        }
private Node root;              // Root of the k-d tree
        private int dimensions;         // Number of dimensions of the vectors

        // Builds the k-d tree by recursively dividing the data
        public void buildTree(List<Word> words, int depth) {
            dimensions = words.get(0).vector.length;            // Set the number of dimensions
            root = buildTreeRecursive(words, depth);            // Start building from root
        }

        // Helper method to recursively build the tree
        private Node buildTreeRecursive(List<Word> words, int depth) {
            if (words.isEmpty()) {
                return null;            // Base case: if the list is empty, return null
            }

            int axis = depth % dimensions;         
            words.sort(Comparator.comparingDouble(w -> w.vector[axis]));  // Sort words by chosen dimension

            int medianIndex = words.size() / 2;         // Find the middle word
            Word medianWord = words.get(medianIndex);   // Get the median word

            Node node = new Node(medianWord, axis);                                                     // Create a new node with the median word
            node.left = buildTreeRecursive(words.subList(0, medianIndex), depth + 1);                   // Build the left subtree
            node.right = buildTreeRecursive(words.subList(medianIndex + 1, words.size()), depth + 1);   // Build the right subtree

            return node;  // Return the node
        }
public Word findNearN(float[] targetVector) {
            return findNearNRec(root, targetVector, Double.MAX_VALUE, null);        // Start recursion from the root
        }

        // Helper method for recursively finding the nearest neighbor
        private Word findNearNRec(Node node, float[] targetVector, double bestDist, Word bestWord) {
            if (node == null) {
                return bestWord;                  // Base case: if node is null, return the best word
            }

            double dist = calcDist(targetVector, node.word.vector);     // Calculate the distance between target and current node
            if (dist < bestDist) {
                bestDist = dist;                                        // Update best distance if a closer neighbor is found
                bestWord = node.word;                                   // Update best word with current node's word
            }

            Node nearNode = targetVector[node.dimension] < node.word.vector[node.dimension] ? node.left : node.right;
            Node farNode = targetVector[node.dimension] < node.word.vector[node.dimension] ? node.right : node.left;

            // Go through the near subtree
            bestWord = findNearNRec(nearNode, targetVector, bestDist, bestWord);

            // Go through the far subtree (if necessary)
            if (Math.abs(targetVector[node.dimension] - node.word.vector[node.dimension]) < bestDist) {
                bestWord = findNearNRec(farNode, targetVector, bestDist, bestWord);
            }

            return bestWord;        // Return the best word found
        }
